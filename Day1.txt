

		E	|	B		
		-----------------
		S	|	I


			who
			|Employee|Developer
			|Tester|Deployers|DBA...
		---------------------
		|		|
		where		when
		|Pune		|2024 Jan	
	----------------------------------
	|		|		|
	why		what		how
	|		|		|	
	Java		InFORMation	Implementation
					.......
					1,2,3,4,5
	


		Java Technology
			|
	-----------------------------------
	|		|		|
	JSE		JEE		JME
	Standard	Enterprise	Micro
	|		|		|
	Core		---------		
Desktop application	|	|
Language Fundas		WEB	EJB	
OOPS			http	non-http
Packages		|		|
Exception handling	Servlet	------------------
Multithreading		JSP	|	|	|
Generics			Session Entity	Message
Collections			|	   |	   |	
File IO		    Stateless  Stateful  BMP CMP SMS Mail
JJDBC		bookmyshow	
|
Advanced Java
|
Networking
RMI



	Four Types of Functions


1. Function without argument and function without return value
2. Function with argument but without return value
3. Function with argument and with return value
4. Function without argument but with return value



Features of Enterprise application

1. RC
2. HA
3. MT
4. POR
5. COR
6. TM
7. SM



Frequency				Frequency
|					|
invisible				visible
|					|
Unmanifest				Manifest
Thought  + Feelings(Emotions)		Action + Result

			TEAR


OOPS Concepts
--------------
1. Abstraction
		
	- It is the "what is?" part of an object
	- hiding the complexity of an object

Farmer --> What is an Atm?"

		- dispense cash
		
	a. data abstraction
		private long totalNumberOfHits;

	b. procedural abstraction
		private void logTheUser() { }
		private void dispenseCash() { } 
	c. class abstraction
		private class Permission { }

 
2. Encapsulation

	- It is the "How is it?" part of an object
	- writing the complexity of an object

		- how is it dispensed?


	class ATM {
		
		private long calculateTotalNumberOfHits() {
			totalNumberOfHits++;
		}
		private dispenseCash() {
			..actual code to deal with the h/w
		}
		void withdraw(float amt) {
			...
			...
			dispenseCash(amt);
			..
			..
		}
	}


3. Polymorhism

	- ability of a business entity to have many forms
	  
	a. class extension

			Doctor
			|
		----------------
		|
		Surgeon
		|isA
	------------------
	|isA		|
HeartSurgeon	NeuroSurgeon

	b. function overloading
		ability of a function to be redefined with same name
		but they all can be differentiated on the following terms
			i. number of paremeters/arguments
			ii. type of parameters
			iii. sequence of type of parameters

	c. function overriding
		- let child class redefine a function that is present
		in its super class
		- 
		class BankAccount {
			float balance;
			void withdraw(float amt) { //OVERRIDDEN
				balance -= amt;
			}
		}

		class SavingsAccount extends BankAccount {
			void withdraw(float amt) { // OVERRIDING
				if( amt > (balance-5000) ) {
					sop("maintain min bal as 5000");
				}
				else 
					super.withdraw(amt);
			}
		}
		class FixedDepositAccount extends SavingsAccount {
			float maturityDate;
			void withdraw(float amt) {
				if(maturityDate < currentDate) {
					sop("account not matured..cannot withdraw");
				}
				else
					super.withdraw(amt);
			}
		}

	d. operator overloading


	class Doctor
	{
		void diagnose() {
		}
		void diagnose(int level) {
		}
		void diagnose(float time) {
		}
		void diagnose(int level, float time) {
		}
		void diagnose(float time, int level ) {
		}

	}
	class Surgeon extends Doctor {
		void diagnose() { // same signature as of the
		}			// super class function
	}
	class HeartSurgeon extends Surgeon {
		void diagnose() {
		}
	}

	Doctor d = new Doctor();
			// C++ Doctor *ptr = new Doctor();

	d.diagnose(); // Doctor::diagnose();

	d.diagnose(5.4f);
	d.diagnose(8);

	d = new Surgeon();

d.diagnose(); // Doctor::diagnose(); compile-time binding

		//Surgeon::diagnose(); run-time binding


		BankAccount
			|withdraw(float amt);
	---------------------------------
	|		|		|
	SavingsAccount CurrentAccount CreditAccount
	withdraw(float)	withdraw(float) withdraw(float)
	  maintain	maintain	maintain
 	  min bal	overdraf	creditlimit


	BankAccount baAcc;

	baAcc = new SavingsAccount();

	OR

	baAcc = new CurrentAccount();
		
	OR

	baAcc = new CreditAccount();

	------------

	baAcc.withdraw(); -- BankAccount::withdraw();

	








4. Inheritance

	- ability of a business entity to acquire properties
	  from other existing entities


		BankAccount baAcc1 = new BankAccount();
		BankAccount baAcc2 = new BankAccount();
		BankAccount baAcc3 = new BankAccount();
		BankAccount baAcc4 = new BankAccount();
		BankAccount baAcc5 = new BankAccount();
		BankAccount baAcc6 = new BankAccount();



	STACK				HEAP
	|				|
					FIELD AREA
			accountNumber accountHolder accountBalance
			------------------------------------------	
			|	     |   	   |		 |
			------------------------------------------	
			10020
	+-------------->
	|				METHOD AREA
	10020				BankAccount() { }
	baAcc1				withdraw(amt) { }
					deposit(amt) { }
					showBankAccount(){}

			accountNumber accountHolder accountBalance
			------------------------------------------	
			|	     |   	   |		 |
			------------------------------------------	
			10070
	+-------------->
	|				
	10070				
	baAcc2c2c				























